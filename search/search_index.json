{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"aviato-client","text":"<p>A Python client library for Aviato sandboxes.</p>"},{"location":"#development","title":"Development","text":"<p>See CONTRIBUTING and DEVELOPMENT.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import asyncio\nfrom aviato import Sandbox\n\nasync def main():\n    # Quick one-liner with factory method\n    sandbox = await Sandbox.create(\"echo\", \"Hello, World!\")\n    await sandbox.stop()\n\n    # Or with context manager for automatic cleanup\n    async with Sandbox(\n        command=\"sleep\",\n        args=[\"infinity\"],\n        container_image=\"python:3.11\",\n    ) as sandbox:\n        result = await sandbox.exec([\"python\", \"-c\", \"print(2 + 2)\"])\n        print(result.stdout)  # 4\n\nasyncio.run(main())\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#environment-variables","title":"Environment Variables","text":"<p>The SDK supports two authentication strategies. Aviato credentials take priority if both are configured.</p>"},{"location":"#aviato-authentication","title":"Aviato Authentication","text":"<ul> <li><code>AVIATO_API_KEY</code> - API key for Aviato authentication</li> <li><code>AVIATO_BASE_URL</code> - Aviato API URL (default: <code>https://atc.cwaviato.com</code>)</li> </ul>"},{"location":"#weights-biases-authentication","title":"Weights &amp; Biases Authentication","text":"<ul> <li><code>WANDB_API_KEY</code> - W&amp;B API key (or use <code>~/.netrc</code> with <code>api.wandb.ai</code>)</li> <li><code>WANDB_ENTITY_NAME</code> - W&amp;B entity/team name (required for W&amp;B auth)</li> <li><code>WANDB_PROJECT_NAME</code> - W&amp;B project name (default: <code>uncategorized</code>)</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#aviato","title":"aviato","text":"<p>A Python client library for Aviato sandboxes.</p>"},{"location":"api/#aviato.WandbAuthError","title":"WandbAuthError","text":"<p>Raised when W&amp;B authentication is misconfigured.</p>"},{"location":"api/#aviato.SandboxDefaults","title":"SandboxDefaults  <code>dataclass</code>","text":"<pre><code>SandboxDefaults(\n    container_image: str = DEFAULT_CONTAINER_IMAGE,\n    command: str = DEFAULT_COMMAND,\n    args: tuple[str, ...] = DEFAULT_ARGS,\n    base_url: str = DEFAULT_BASE_URL,\n    request_timeout_seconds: float = DEFAULT_REQUEST_TIMEOUT_SECONDS,\n    max_lifetime_seconds: float\n    | None = DEFAULT_MAX_LIFETIME_SECONDS,\n    temp_dir: str = DEFAULT_TEMP_DIR,\n    tags: tuple[str, ...] = tuple(),\n    runway_ids: tuple[str, ...] | None = None,\n    tower_ids: tuple[str, ...] | None = None,\n)\n</code></pre> <p>Immutable configuration defaults for sandbox creation.</p> <p>All fields have sensible defaults. Override only what you need.</p> <p>There are two separate timeout concepts: - request_timeout_seconds: How long to wait for API responses (client-side) - max_lifetime_seconds: How long the sandbox runs before auto-termination (server-side)   If not set, the backend controls the default lifetime.</p> <p>Tags enable filtering and organizing sandboxes. They are propagated to the backend and can be used to query sandboxes by tag.</p> Example <p>defaults = SandboxDefaults(     container_image=\"python:3.12\",     command=\"tail\",     args=(\"-f\", \"/dev/null\"),     request_timeout_seconds=60,     max_lifetime_seconds=3600,  # 1 hour sandbox lifetime     tags=(\"my-workload\", \"experiment-42\"), )</p>"},{"location":"api/#aviato.SandboxDefaults.merge_tags","title":"merge_tags","text":"<pre><code>merge_tags(additional: list[str] | None) -&gt; list[str]\n</code></pre> <p>Combine default tags with additional tags.</p> <p>Tags from both sources are included. Order is: defaults first, then additional tags appended.</p>"},{"location":"api/#aviato.SandboxDefaults.with_overrides","title":"with_overrides","text":"<pre><code>with_overrides(**kwargs: Any) -&gt; SandboxDefaults\n</code></pre> <p>Create new defaults with some values overridden.</p>"},{"location":"api/#aviato.Sandbox","title":"Sandbox","text":"<pre><code>Sandbox(\n    *,\n    command: str | None = None,\n    args: list[str] | None = None,\n    defaults: SandboxDefaults | None = None,\n    container_image: str | None = None,\n    tags: list[str] | None = None,\n    base_url: str | None = None,\n    request_timeout_seconds: float | None = None,\n    max_lifetime_seconds: float | None = None,\n    runway_ids: list[str] | None = None,\n    tower_ids: list[str] | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n    _session: Session | None = None,\n)\n</code></pre> <p>Aviato sandbox client.</p> <p>Supports two construction patterns:</p> <p>Constructor (with context manager): <pre><code>async with Sandbox(\n    command=\"sleep\",\n    args=[\"infinity\"],\n    container_image=\"python:3.11\",\n) as sandbox:\n    result = await sandbox.exec([\"echo\", \"hello\"])\n</code></pre></p> <p>Factory method (for quick one-liners): <pre><code>sandbox = await Sandbox.create(\"echo\", \"hello\", \"world\")\nawait sandbox.stop()\n</code></pre></p> <p>Initialize a sandbox (does not start it).</p> PARAMETER DESCRIPTION <code>command</code> <p>Optional command to run in the sandbox</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>args</code> <p>Optional arguments for the command</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>defaults</code> <p>Optional SandboxDefaults to apply</p> <p> TYPE: <code>SandboxDefaults | None</code> DEFAULT: <code>None</code> </p> <code>container_image</code> <p>Container image to use (default: python:3.11)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tags</code> <p>Optional tags for the sandbox</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>base_url</code> <p>Aviato API URL (default: AVIATO_BASE_URL env or localhost)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>request_timeout_seconds</code> <p>Timeout for API requests (client-side, default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_lifetime_seconds</code> <p>Max sandbox lifetime (server-side). If not set, the backend controls the default.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>runway_ids</code> <p>Optional list of runway IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>tower_ids</code> <p>Optional list of tower IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#aviato.Sandbox.sandbox_id","title":"sandbox_id  <code>property</code>","text":"<pre><code>sandbox_id: str | None\n</code></pre> <p>The unique sandbox ID, or None if not yet started.</p>"},{"location":"api/#aviato.Sandbox.returncode","title":"returncode  <code>property</code>","text":"<pre><code>returncode: int | None\n</code></pre> <p>Exit code if sandbox has completed, None if still running.</p> <p>Use wait() to block until the sandbox completes.</p>"},{"location":"api/#aviato.Sandbox.tower_id","title":"tower_id  <code>property</code>","text":"<pre><code>tower_id: str | None\n</code></pre> <p>Tower where sandbox is running, or None if not started.</p>"},{"location":"api/#aviato.Sandbox.runway_id","title":"runway_id  <code>property</code>","text":"<pre><code>runway_id: str | None\n</code></pre> <p>Runway where sandbox is running, or None if not started.</p>"},{"location":"api/#aviato.Sandbox.status","title":"status  <code>property</code>","text":"<pre><code>status: SandboxStatus | None\n</code></pre> <p>Last known status of the sandbox.</p> <p>This is the cached status from the most recent API interaction.</p> <p>Returns None only for sandboxes that haven't been started yet.</p> <p>Note: This value may be stale. Check status_updated_at for when it was last fetched. For guaranteed fresh status, use <code>await sandbox.get_status()</code> which always hits the API.</p>"},{"location":"api/#aviato.Sandbox.status_updated_at","title":"status_updated_at  <code>property</code>","text":"<pre><code>status_updated_at: datetime | None\n</code></pre> <p>Timestamp when status was last fetched from the API.</p> <p>Returns None only for sandboxes that haven't been started yet.</p>"},{"location":"api/#aviato.Sandbox.started_at","title":"started_at  <code>property</code>","text":"<pre><code>started_at: datetime | None\n</code></pre> <p>Timestamp when the sandbox was started.</p> <p>Populated after start() completes or when obtained via list()/from_id(). None only for sandboxes that haven't been started yet.</p>"},{"location":"api/#aviato.Sandbox.tower_group_id","title":"tower_group_id  <code>property</code>","text":"<pre><code>tower_group_id: str | None\n</code></pre> <p>Tower group ID where the sandbox is running.</p>"},{"location":"api/#aviato.Sandbox.create","title":"create  <code>async</code> <code>classmethod</code>","text":"<pre><code>create(\n    *args: str,\n    container_image: str | None = None,\n    defaults: SandboxDefaults | None = None,\n    request_timeout_seconds: float | None = None,\n    max_lifetime_seconds: float | None = None,\n    tags: list[str] | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n) -&gt; Sandbox\n</code></pre> <p>Factory method for quick sandbox creation with auto-start.</p> <p>The first positional arg is the command, remaining args are its arguments. The sandbox is started before returning.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Command and arguments (e.g., \"echo\", \"hello\", \"world\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>container_image</code> <p>Container image to use</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>defaults</code> <p>Optional SandboxDefaults to apply</p> <p> TYPE: <code>SandboxDefaults | None</code> DEFAULT: <code>None</code> </p> <code>request_timeout_seconds</code> <p>Timeout for API requests (client-side)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_lifetime_seconds</code> <p>Max sandbox lifetime (server-side)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>tags</code> <p>Optional tags for the sandbox</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>A started Sandbox instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no positional arguments provided</p> <code>SandboxFailedError</code> <p>If sandbox fails to start</p> <code>SandboxTimeoutError</code> <p>If start times out</p> Example <pre><code>sandbox = await Sandbox.create(\"echo\", \"hello\")\nawait sandbox.stop()\n\n# With options\nsandbox = await Sandbox.create(\n    \"python\", \"train.py\",\n    container_image=\"pytorch/pytorch:latest\",\n    resources={\"cpu\": \"2\", \"memory\": \"4Gi\"},\n)\nawait sandbox.stop()\n</code></pre>"},{"location":"api/#aviato.Sandbox.session","title":"session  <code>classmethod</code>","text":"<pre><code>session(defaults: SandboxDefaults | None = None) -&gt; Session\n</code></pre> <p>Create a session for managing multiple sandboxes.</p> <p>Sessions provide: - Shared configuration via defaults - Automatic cleanup of orphaned sandboxes - Function execution via @session.function() decorator</p> PARAMETER DESCRIPTION <code>defaults</code> <p>Optional defaults to apply to sandboxes created via session</p> <p> TYPE: <code>SandboxDefaults | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Session</code> <p>A Session instance</p> Example <pre><code>session = Sandbox.session(defaults)\nsb = session.create(command=\"sleep\", args=[\"infinity\"])\n\n@session.function()\ndef compute(x, y):\n    return x + y\n\nawait session.close()\n</code></pre>"},{"location":"api/#aviato.Sandbox.list","title":"list  <code>async</code> <code>classmethod</code>","text":"<pre><code>list(\n    *,\n    tags: list[str] | None = None,\n    status: str | None = None,\n    runway_ids: list[str] | None = None,\n    tower_ids: list[str] | None = None,\n    base_url: str | None = None,\n    timeout_seconds: float | None = None,\n) -&gt; list[Sandbox]\n</code></pre> <p>List existing sandboxes with optional filters.</p> <p>Returns Sandbox instances that can be used for operations like exec(), stop(), get_status(), read_file(), write_file(), etc.</p> PARAMETER DESCRIPTION <code>tags</code> <p>Filter by tags (sandboxes must have ALL specified tags)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>Filter by status (\"running\", \"completed\", \"failed\", etc.)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>runway_ids</code> <p>Filter by runway IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>tower_ids</code> <p>Filter by tower IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>base_url</code> <p>Override API URL (default: AVIATO_BASE_URL env or default)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout_seconds</code> <p>Request timeout (default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Sandbox]</code> <p>List of Sandbox instances for matching sandboxes</p> Example <pre><code>sandboxes = await Sandbox.list(tags=[\"my-batch-job\"])\nfor sb in sandboxes:\n    print(f\"{sb.sandbox_id}: {sb.status}\")\n    await sb.stop()\n</code></pre>"},{"location":"api/#aviato.Sandbox.from_id","title":"from_id  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_id(\n    sandbox_id: str,\n    *,\n    base_url: str | None = None,\n    timeout_seconds: float | None = None,\n) -&gt; Sandbox\n</code></pre> <p>Attach to an existing sandbox by ID.</p> <p>Creates a Sandbox instance connected to an existing sandbox, allowing operations like exec(), stop(), get_status(), etc.</p> PARAMETER DESCRIPTION <code>sandbox_id</code> <p>The ID of the existing sandbox</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>Override API URL (default: AVIATO_BASE_URL env or default)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout_seconds</code> <p>Request timeout (default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>A Sandbox instance attached to the existing sandbox</p> RAISES DESCRIPTION <code>SandboxNotFoundError</code> <p>If sandbox doesn't exist</p> Example <pre><code>sb = await Sandbox.from_id(\"sandbox-abc123\")\nresult = await sb.exec([\"python\", \"-c\", \"print('hello')\"])\nawait sb.stop()\n</code></pre>"},{"location":"api/#aviato.Sandbox.delete","title":"delete  <code>async</code> <code>classmethod</code>","text":"<pre><code>delete(\n    sandbox_id: str,\n    *,\n    base_url: str | None = None,\n    timeout_seconds: float | None = None,\n    missing_ok: bool = False,\n) -&gt; bool\n</code></pre> <p>Delete a sandbox by ID without creating a Sandbox instance.</p> <p>This is a convenience method for cleanup scenarios where you don't need to perform other operations on the sandbox.</p> PARAMETER DESCRIPTION <code>sandbox_id</code> <p>The sandbox ID to delete</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>Override API URL (default: AVIATO_BASE_URL env or default)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout_seconds</code> <p>Request timeout (default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>missing_ok</code> <p>If True, return False instead of raising when sandbox doesn't exist</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if sandbox was deleted successfully, False if missing_ok=True and not found</p> RAISES DESCRIPTION <code>SandboxNotFoundError</code> <p>If sandbox doesn't exist and missing_ok=False</p> <code>SandboxError</code> <p>If deletion failed for other reasons</p> Example <pre><code>await Sandbox.delete(\"sandbox-abc123\")\nawait Sandbox.delete(\"sandbox-abc123\", missing_ok=True)\n</code></pre>"},{"location":"api/#aviato.Sandbox.get_status","title":"get_status  <code>async</code>","text":"<pre><code>get_status() -&gt; SandboxStatus\n</code></pre> <p>Get the current status of the sandbox from the backend.</p> RETURNS DESCRIPTION <code>SandboxStatus</code> <p>SandboxStatus enum value</p> RAISES DESCRIPTION <code>SandboxNotRunningError</code> <p>If sandbox has not been started</p> Example <pre><code>sandbox = await Sandbox.create(\"sleep\", \"10\")\nstatus = await sandbox.get_status()  # SandboxStatus.RUNNING\nawait sandbox.wait()\nstatus = await sandbox.get_status()  # SandboxStatus.COMPLETED\n</code></pre>"},{"location":"api/#aviato.Sandbox.start","title":"start  <code>async</code>","text":"<pre><code>start(*, timeout_seconds: float | None = None) -&gt; str\n</code></pre> <p>Start the sandbox and wait for it to be ready.</p> RETURNS DESCRIPTION <code>str</code> <p>The sandbox ID</p> RAISES DESCRIPTION <code>SandboxFailedError</code> <p>If sandbox fails to start</p> <code>SandboxTimeoutError</code> <p>If start operation times out</p> Example <pre><code>sandbox = Sandbox(command=\"sleep\", args=[\"infinity\"])\nsandbox_id = await sandbox.start()\nprint(f\"Started: {sandbox_id}, tower: {sandbox.tower_id}\")\n</code></pre>"},{"location":"api/#aviato.Sandbox.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    *,\n    raise_on_termination: bool = True,\n    timeout_seconds: float | None = None,\n) -&gt; None\n</code></pre> <p>Wait for the sandbox to complete.</p> <p>Blocks until the sandbox process exits. After this returns successfully, returncode will be available.</p> PARAMETER DESCRIPTION <code>raise_on_termination</code> <p>If True (default), raises SandboxTerminatedError if sandbox was terminated externally. Set to False to handle termination gracefully without exceptions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timeout_seconds</code> <p>Optional timeout for the wait operation.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>SandboxTimeoutError</code> <p>If the sandbox or wait operation times out</p> <code>SandboxTerminatedError</code> <p>If sandbox was terminated (and raise_on_termination=True)</p> <code>SandboxFailedError</code> <p>If sandbox failed</p> Example <pre><code>sandbox = await Sandbox.create(\"python\", \"-c\", \"print('done')\")\nawait sandbox.wait()\nprint(f\"Exit code: {sandbox.returncode}\")\n</code></pre>"},{"location":"api/#aviato.Sandbox.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(\n    *,\n    snapshot_on_stop: bool = False,\n    graceful_shutdown_seconds: float = DEFAULT_GRACEFUL_SHUTDOWN_SECONDS,\n) -&gt; bool\n</code></pre> <p>Stop the sandbox and close the client.</p> <p>The sandbox is deregistered from its session regardless of whether the stop was successful, since the sandbox is no longer usable.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the backend confirmed the stop (or sandbox was already</p> <code>bool</code> <p>stopped), False if the stop failed.</p>"},{"location":"api/#aviato.Sandbox.exec","title":"exec  <code>async</code>","text":"<pre><code>exec(\n    command: list[str],\n    *,\n    check: bool = False,\n    timeout_seconds: float | None = None,\n) -&gt; ExecResult\n</code></pre> <p>Execute a command in the running sandbox.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command and arguments to execute</p> <p> TYPE: <code>list[str]</code> </p> <code>check</code> <p>If True, raise SandboxExecutionError on non-zero returncode</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout_seconds</code> <p>Timeout for the command execution</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ExecResult</code> <p>ExecResult with stdout, stderr, and returncode</p> RAISES DESCRIPTION <code>SandboxNotRunningError</code> <p>If sandbox is not running</p> <code>SandboxExecutionError</code> <p>If check=True and command returns non-zero</p> <code>SandboxTimeoutError</code> <p>If command exceeds timeout_seconds</p> <code>ConnectError</code> <p>If an unexpected error occurs</p>"},{"location":"api/#aviato.Sandbox.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(\n    filepath: str, *, timeout_seconds: float | None = None\n) -&gt; bytes\n</code></pre> <p>Read a file from the sandbox filesystem.</p> RAISES DESCRIPTION <code>SandboxNotRunningError</code> <p>If sandbox is not running</p> <code>TimeoutError</code> <p>If operation exceeds timeout_seconds</p>"},{"location":"api/#aviato.Sandbox.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(\n    filepath: str,\n    contents: bytes,\n    *,\n    timeout_seconds: float | None = None,\n) -&gt; None\n</code></pre> <p>Write a file to the sandbox filesystem.</p> RAISES DESCRIPTION <code>SandboxNotRunningError</code> <p>If sandbox is not running</p> <code>SandboxFileError</code> <p>If the file could not be written</p> <code>TimeoutError</code> <p>If operation exceeds timeout_seconds</p>"},{"location":"api/#aviato.SandboxStatus","title":"SandboxStatus","text":"<p>Sandbox status values.</p>"},{"location":"api/#aviato.SandboxStatus.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(proto_status: int) -&gt; SandboxStatus\n</code></pre> <p>Convert protobuf status enum to SandboxStatus</p>"},{"location":"api/#aviato.SandboxStatus.to_proto","title":"to_proto","text":"<pre><code>to_proto() -&gt; int\n</code></pre> <p>Convert SandboxStatus to protobuf enum</p>"},{"location":"api/#aviato.Session","title":"Session","text":"<pre><code>Session(defaults: SandboxDefaults | None = None)\n</code></pre> <p>Manages sandbox lifecycle and provides function execution.</p> <p>Use a session when: - Creating multiple sandboxes with shared configuration - Executing Python functions in sandboxes - You want automatic cleanup of orphaned sandboxes</p> Example <pre><code>defaults = SandboxDefaults(container_image=\"python:3.11\")\n\nasync with Session(defaults) as session:\n    sb = session.create(command=\"sleep\", args=[\"infinity\"])\n    async with sb:\n        await sb.exec([\"echo\", \"hello\"])\n\n    @session.function()\n    def compute(x: int, y: int) -&gt; int:\n        return x + y\n\n    result = await compute(2, 3)  # 5\n</code></pre>"},{"location":"api/#aviato.Session.sandbox_count","title":"sandbox_count  <code>property</code>","text":"<pre><code>sandbox_count: int\n</code></pre> <p>Number of sandboxes currently tracked by this session.</p>"},{"location":"api/#aviato.Session.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Stop all managed sandboxes concurrently.</p> RAISES DESCRIPTION <code>SandboxError</code> <p>If one or more running sandboxes failed to stop.</p>"},{"location":"api/#aviato.Session.create","title":"create","text":"<pre><code>create(\n    *,\n    command: str | None = None,\n    args: list[str] | None = None,\n    container_image: str | None = None,\n    tags: list[str] | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n) -&gt; Sandbox\n</code></pre> <p>Create a sandbox with session defaults applied.</p> RAISES DESCRIPTION <code>SandboxError</code> <p>If the session has been closed.</p>"},{"location":"api/#aviato.Session.list","title":"list  <code>async</code>","text":"<pre><code>list(\n    *,\n    tags: list[str] | None = None,\n    status: str | None = None,\n    runway_ids: list[str] | None = None,\n    tower_ids: list[str] | None = None,\n    adopt: bool = False,\n) -&gt; list[Sandbox]\n</code></pre> <p>List sandboxes, optionally adopting them into this session.</p> <p>Automatically includes the session's default tags in the filter. This makes it easy to find sandboxes created by this session or a previous run with the same defaults.</p> PARAMETER DESCRIPTION <code>tags</code> <p>Additional tags to filter by (merged with session's default tags)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>Filter by status</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>runway_ids</code> <p>Filter by runway IDs (defaults to session's runway_ids if set)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>tower_ids</code> <p>Filter by tower IDs (defaults to session's tower_ids if set)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>adopt</code> <p>If True, register discovered sandboxes with this session    so they are stopped when the session closes</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[Sandbox]</code> <p>List of Sandbox instances</p> Example <pre><code>defaults = SandboxDefaults(tags=(\"my-app\", \"run-123\"))\nasync with Session(defaults) as session:\n    orphans = await session.list(adopt=True)\n    running = await session.list(status=\"running\")\n</code></pre>"},{"location":"api/#aviato.Session.from_id","title":"from_id  <code>async</code>","text":"<pre><code>from_id(sandbox_id: str, *, adopt: bool = True) -&gt; Sandbox\n</code></pre> <p>Attach to an existing sandbox, optionally adopting it into this session.</p> PARAMETER DESCRIPTION <code>sandbox_id</code> <p>The ID of the existing sandbox</p> <p> TYPE: <code>str</code> </p> <code>adopt</code> <p>If True (default), register the sandbox with this session</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>A Sandbox instance attached to the existing sandbox</p> Example <pre><code>async with Session(defaults) as session:\n    sb = await session.from_id(\"sandbox-abc123\")\n    await sb.exec([\"echo\", \"hello\"])\n</code></pre>"},{"location":"api/#aviato.Session.adopt","title":"adopt","text":"<pre><code>adopt(sandbox: Sandbox) -&gt; None\n</code></pre> <p>Adopt an existing Sandbox instance into this session for cleanup tracking.</p> <p>Use this when you have a Sandbox from Sandbox.list() or Sandbox.from_id() that you want to be automatically stopped when the session closes.</p> PARAMETER DESCRIPTION <code>sandbox</code> <p>A Sandbox instance to track</p> <p> TYPE: <code>Sandbox</code> </p> RAISES DESCRIPTION <code>SandboxError</code> <p>If the session is closed</p> <code>ValueError</code> <p>If the sandbox has no sandbox_id</p> Example <pre><code>async with Session(defaults) as session:\n    sandboxes = await Sandbox.list(tags=[\"my-job\"])\n    for sb in sandboxes:\n        session.adopt(sb)\n</code></pre>"},{"location":"api/#aviato.Session.function","title":"function","text":"<pre><code>function(\n    *,\n    container_image: str | None = None,\n    serialization: Serialization = JSON,\n    temp_dir: str | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n) -&gt; Callable[\n    [Callable[P, R]], Callable[P, Awaitable[R]]\n]\n</code></pre> <p>Decorator to execute a Python function in a sandbox.</p> <p>Each function call creates an ephemeral sandbox, executes the function, and returns the result. The sandbox is automatically cleaned up.</p> <p>The decorated function must be synchronous. Async functions are not supported.</p> PARAMETER DESCRIPTION <code>container_image</code> <p>Override session's default image for this function</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>serialization</code> <p>How to serialize arguments and return values. Defaults to JSON for safety. Use PICKLE for complex types, but only in trusted environments.</p> <p> TYPE: <code>Serialization</code> DEFAULT: <code>JSON</code> </p> <code>temp_dir</code> <p>Override temp directory for payload/result files in sandbox. Defaults to session default. Created if missing.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, Awaitable[R]]]</code> <p>A decorator that wraps a function for async execution in a sandbox</p> Example <pre><code>async with Session(defaults) as session:\n    @session.function()\n    def compute(x: int, y: int) -&gt; int:\n        return x + y\n\n    result = await compute(2, 3)  # 5\n</code></pre>"},{"location":"api/#aviato.ExecResult","title":"ExecResult  <code>dataclass</code>","text":"<pre><code>ExecResult(\n    stdout_bytes: bytes,\n    stderr_bytes: bytes,\n    returncode: int,\n    command: list[str] = list(),\n)\n</code></pre> <p>Result from a completed sandbox exec operation.</p> ATTRIBUTE DESCRIPTION <code>stdout_bytes</code> <p>Raw stdout bytes from the command</p> <p> TYPE: <code>bytes</code> </p> <code>stderr_bytes</code> <p>Raw stderr bytes from the command</p> <p> TYPE: <code>bytes</code> </p> <code>returncode</code> <p>Exit code from the command</p> <p> TYPE: <code>int</code> </p> <code>command</code> <p>The command that was executed (for debugging)</p> <p> TYPE: <code>list[str]</code> </p> Properties <p>stdout: Lazily decoded stdout as UTF-8 string stderr: Lazily decoded stderr as UTF-8 string</p>"},{"location":"api/#aviato.ExecResult.stdout","title":"stdout  <code>cached</code> <code>property</code>","text":"<pre><code>stdout: str\n</code></pre> <p>Decode stdout as UTF-8 (lazy, cached).</p>"},{"location":"api/#aviato.ExecResult.stderr","title":"stderr  <code>cached</code> <code>property</code>","text":"<pre><code>stderr: str\n</code></pre> <p>Decode stderr as UTF-8 (lazy, cached).</p>"},{"location":"api/#aviato.Serialization","title":"Serialization","text":"<p>Serialization modes for sandbox function execution.</p>"},{"location":"api/#aviato.AsyncFunctionError","title":"AsyncFunctionError","text":"<p>Raised when an async function is passed to @session.function().</p> <p>Async functions are not supported because the sandbox executes Python synchronously. The decorated function must be a regular (sync) function.</p>"},{"location":"api/#aviato.AviatoAuthenticationError","title":"AviatoAuthenticationError","text":"<p>Raised when authentication fails.</p>"},{"location":"api/#aviato.AviatoError","title":"AviatoError","text":"<p>Base exception for all Aviato operations.</p>"},{"location":"api/#aviato.FunctionError","title":"FunctionError","text":"<p>Base exception for function execution operations.</p>"},{"location":"api/#aviato.FunctionSerializationError","title":"FunctionSerializationError","text":"<p>Raised when arguments, referenced globals, or closures cannot be serialized.</p>"},{"location":"api/#aviato.SandboxError","title":"SandboxError","text":"<p>Base exception for sandbox operations.</p>"},{"location":"api/#aviato.SandboxExecutionError","title":"SandboxExecutionError","text":"<pre><code>SandboxExecutionError(\n    message: str,\n    *,\n    exec_result: ExecResult | None = None,\n    exception_type: str | None = None,\n    exception_message: str | None = None,\n)\n</code></pre> <p>Raised when command execution fails inside a sandbox.</p> <p>Access execution details via exec_result</p>"},{"location":"api/#aviato.SandboxFailedError","title":"SandboxFailedError","text":"<p>Raised when a sandbox fails to start or encounters a fatal error.</p>"},{"location":"api/#aviato.SandboxFileError","title":"SandboxFileError","text":"<pre><code>SandboxFileError(\n    message: str, *, filepath: str | None = None\n)\n</code></pre> <p>Raised when a file operation fails in the sandbox.</p> <p>This is a sandbox infrastructure error, not a user code error. Inherits from SandboxError since it's a sandbox operation failure.</p>"},{"location":"api/#aviato.SandboxNotFoundError","title":"SandboxNotFoundError","text":"<pre><code>SandboxNotFoundError(\n    message: str, *, sandbox_id: str | None = None\n)\n</code></pre> <p>Raised when a sandbox is not found (e.g., already deleted).</p>"},{"location":"api/#aviato.SandboxNotRunningError","title":"SandboxNotRunningError","text":"<p>Raised when an operation requires a running sandbox.</p>"},{"location":"api/#aviato.SandboxTerminatedError","title":"SandboxTerminatedError","text":"<p>Raised when a sandbox was terminated externally.</p>"},{"location":"api/#aviato.SandboxTimeoutError","title":"SandboxTimeoutError","text":"<p>Raised when a sandbox operation times out.</p>"},{"location":"examples/basic-execution/","title":"Basic Execution","text":"<p>This example demonstrates basic sandbox operations: creating a sandbox, executing commands, and file operations.</p>"},{"location":"examples/basic-execution/#quick-start-with-factory-method","title":"Quick Start with Factory Method","text":"<p>The simplest way to create a sandbox:</p> <pre><code>import asyncio\nfrom aviato import Sandbox\n\nasync def main():\n    # Factory method parses positional args as command + args\n    sandbox = await Sandbox.create(\"echo\", \"hello\", \"world\")\n    print(f\"Sandbox ID: {sandbox.sandbox_id}\")\n    await sandbox.stop()\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/basic-execution/#constructor-with-context-manager","title":"Constructor with Context Manager","text":"<p>For more control, use the constructor with a context manager:</p> <pre><code>import asyncio\nfrom aviato import Sandbox, SandboxDefaults\n\nasync def main():\n    # Define reusable defaults\n    defaults = SandboxDefaults(\n        container_image=\"python:3.11\",\n        max_lifetime_seconds=60.0,\n        tags=(\"my-app\", \"production\"),\n    )\n\n    async with Sandbox(\n        command=\"sleep\",\n        args=[\"infinity\"],\n        defaults=defaults,\n    ) as sandbox:\n        # Execute commands\n        result = await sandbox.exec([\"echo\", \"Hello from sandbox\"])\n        print(result.stdout)\n\n        # Check Python version\n        result = await sandbox.exec([\"python\", \"--version\"])\n        print(result.stdout)\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/basic-execution/#file-operations","title":"File Operations","text":"<p>Read and write files in the sandbox:</p> <pre><code>import asyncio\nfrom aviato import Sandbox\n\nasync def main():\n    async with Sandbox(\n        command=\"sleep\",\n        args=[\"infinity\"],\n        container_image=\"python:3.11\",\n    ) as sandbox:\n        # Write a file\n        content = b\"Hello, World!\\n\"\n        await sandbox.write_file(\"/tmp/data.txt\", content)\n        print(f\"Write success: '/tmp/data.txt'\")\n\n        # Read the file back\n        read_back = await sandbox.read_file(\"/tmp/data.txt\")\n        print(f\"Content: {read_back.decode()}\")\n\n        # Verify with cat\n        result = await sandbox.exec([\"cat\", \"/tmp/data.txt\"])\n        print(f\"cat output: {result.stdout}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/basic-execution/#sandbox-properties","title":"Sandbox Properties","text":"<p>Access sandbox metadata:</p> <pre><code>async with Sandbox(\n    command=\"sleep\",\n    args=[\"infinity\"],\n    container_image=\"python:3.11\",\n) as sandbox:\n    print(f\"Sandbox ID: {sandbox.sandbox_id}\")\n    print(f\"Tower ID: {sandbox.tower_id}\")\n    print(f\"Runway ID: {sandbox.runway_id}\")\n</code></pre>"},{"location":"examples/function-decorator/","title":"Function Decorator","text":"<p>The <code>@session.function()</code> decorator allows you to execute Python functions in isolated sandboxes.</p>"},{"location":"examples/function-decorator/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom aviato import Sandbox, SandboxDefaults\n\nasync def main():\n    defaults = SandboxDefaults(container_image=\"python:3.11\")\n\n    async with Sandbox.session(defaults) as session:\n        @session.function()\n        def add(x: int, y: int) -&gt; int:\n            return x + y\n\n        result = await add(2, 3)\n        print(f\"Result: {result}\")  # 5\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/function-decorator/#important-constraints","title":"Important Constraints","text":""},{"location":"examples/function-decorator/#synchronous-functions-only","title":"Synchronous Functions Only","text":"<p>The <code>@session.function()</code> decorator only supports synchronous functions. Async functions are not supported because the sandbox executes Python synchronously.</p> <pre><code># CORRECT: Synchronous function\n@session.function()\ndef compute(x: int) -&gt; int:\n    return x * 2\n\n# ERROR: Async functions are not supported\n@session.function()\nasync def compute_async(x: int) -&gt; int:  # Raises AsyncFunctionError\n    return x * 2\n</code></pre> <p>If you need async behavior inside your sandbox function, run it explicitly:</p> <pre><code>@session.function()\ndef fetch_urls(urls: list[str]) -&gt; list[str]:\n    import asyncio\n    import aiohttp\n\n    async def fetch_all():\n        async with aiohttp.ClientSession() as session:\n            tasks = [session.get(url) for url in urls]\n            responses = await asyncio.gather(*tasks)\n            return [await r.text() for r in responses]\n\n    return asyncio.run(fetch_all())\n</code></pre>"},{"location":"examples/function-decorator/#decorator-order","title":"Decorator Order","text":"<p><code>@session.function()</code> can be placed anywhere in the decorator stack. It will be automatically removed when sending the function to the sandbox, while all other decorators are preserved:</p> <pre><code># Both of these work correctly:\n@session.function()\n@retry(max_attempts=3)\ndef fetch_data(url: str) -&gt; dict:\n    return requests.get(url).json()\n\n@retry(max_attempts=3)\n@session.function()\ndef fetch_data(url: str) -&gt; dict:\n    return requests.get(url).json()\n</code></pre>"},{"location":"examples/function-decorator/#serialization-modes","title":"Serialization Modes","text":""},{"location":"examples/function-decorator/#json-default","title":"JSON (Default)","text":"<p>JSON serialization is the default because it is safe and cannot execute code during deserialization. It supports basic Python types: <code>dict</code>, <code>list</code>, <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, and <code>None</code>.</p> <pre><code>@session.function()  # Uses Serialization.JSON by default\ndef create_config(name: str, value: int) -&gt; dict[str, object]:\n    return {\"name\": name, \"value\": value}\n</code></pre>"},{"location":"examples/function-decorator/#pickle-complex-types","title":"Pickle (Complex Types)","text":"<p>Pickle serialization supports complex Python types but should only be used in trusted environments. Use it when you need to pass custom classes, dataclasses, or other complex objects.</p> <pre><code>from dataclasses import dataclass\nfrom aviato import Serialization\n\n@dataclass\nclass ModelConfig:\n    layers: int\n    learning_rate: float\n\n@session.function(serialization=Serialization.PICKLE)\ndef process_config(config: ModelConfig) -&gt; dict:\n    return {\"layers\": config.layers, \"lr\": config.learning_rate}\n</code></pre>"},{"location":"examples/function-decorator/#security-json-vs-pickle","title":"Security: JSON vs Pickle","text":"<p>Why does serialization mode matter for security?</p> <p>Python's <code>pickle</code> module can execute arbitrary code during deserialization. When using <code>@session.function()</code> with pickle:</p> <ol> <li>Your arguments are pickled and sent to the sandbox</li> <li>The sandbox runs your function and pickles the result</li> <li>Your client deserializes the result from the sandbox</li> </ol> <p>The risk is in step 3: if a sandbox is compromised or running malicious code, it could return a crafted pickle payload that executes arbitrary code on your machine when deserialized.</p> <p>JSON deserialization cannot execute code - it only produces basic Python types.</p> <pre><code># Safe for any environment\n@session.function()\ndef process_data(data: dict) -&gt; dict:\n    return {\"result\": data[\"value\"] * 2}\n\n# Only use with trusted code in the sandbox\n@session.function(serialization=Serialization.PICKLE)\ndef train_model(config: TrainingConfig) -&gt; TrainedModel:\n    return model.train(config)\n</code></pre>"},{"location":"examples/function-decorator/#functions-with-closures-and-globals","title":"Functions with Closures and Globals","text":"<p>Functions can access variables from their enclosing scope (closures) and module-level globals. These are automatically captured and sent to the sandbox.</p> <pre><code># Module-level global\nMULTIPLIER = 10\n\nasync with Sandbox.session(defaults) as session:\n    # Local closure variable\n    offset = 5\n\n    @session.function()\n    def compute(x: int) -&gt; int:\n        return x * MULTIPLIER + offset  # Both captured automatically\n\n    result = await compute(3)\n    print(result)  # 35\n</code></pre>"},{"location":"examples/function-decorator/#serialization-validation","title":"Serialization Validation","text":"<p>Variables must be serializable with the chosen serialization mode. The decorator validates this upfront and provides clear error messages:</p> <pre><code>import threading\n\nlock = threading.Lock()  # Not serializable\n\n@session.function()\ndef broken(x: int) -&gt; int:\n    return x * lock  # ValueError: Variable 'lock' cannot be serialized\n</code></pre>"},{"location":"examples/function-decorator/#custom-container-image","title":"Custom Container Image","text":"<p>Override the session's default container for specific functions:</p> <pre><code>@session.function(container_image=\"pytorch/pytorch:latest\")\ndef train_model(epochs: int) -&gt; float:\n    import torch\n    # ... training logic\n    return final_loss\n</code></pre>"},{"location":"examples/function-decorator/#custom-temp-directory","title":"Custom Temp Directory","text":"<p>By default, payload and result files are stored in <code>/tmp</code> inside the sandbox. Override this if your container image has a different writable directory:</p> <pre><code>@session.function(temp_dir=\"/var/sandbox/temp\")\ndef process(data: dict) -&gt; dict:\n    return {\"processed\": True}\n</code></pre>"},{"location":"examples/function-decorator/#functionresult","title":"FunctionResult","text":"<p>The decorator returns the function's return value directly:</p> <pre><code>result = await my_function(args)\nprint(result)  # Function return value\n</code></pre>"},{"location":"examples/function-decorator/#error-handling","title":"Error Handling","text":"<p>When function execution fails, a <code>SandboxExecutionError</code> is raised with detailed information accessible via <code>exec_result</code>:</p> <pre><code>from aviato import SandboxExecutionError\n\n@session.function()\ndef might_fail(x: int) -&gt; int:\n    if x &lt; 0:\n        raise ValueError(\"x must be non-negative\")\n    return x * 2\n\ntry:\n    result = await might_fail(-1)\nexcept SandboxExecutionError as e:\n    print(f\"Exception type: {e.exception_type}\")  # \"ValueError\"\n    print(f\"Exception message: {e.exception_message}\")  # \"x must be non-negative\"\n    print(f\"Return code: {e.exec_result.returncode}\")  # 1\n    print(f\"Stderr: {e.exec_result.stderr}\")  # Full traceback (decoded)\n</code></pre>"},{"location":"examples/parallel-sandboxes/","title":"Parallel Sandboxes","text":"<p>Use sessions to manage multiple sandboxes and run operations in parallel.</p>"},{"location":"examples/parallel-sandboxes/#creating-multiple-sandboxes","title":"Creating Multiple Sandboxes","text":"<pre><code>import asyncio\nfrom aviato import Sandbox, SandboxDefaults\n\nasync def main():\n    defaults = SandboxDefaults(\n        container_image=\"python:3.11\",\n        max_lifetime_seconds=60.0,\n    )\n\n    async with Sandbox.session(defaults) as session:\n        # Create multiple sandboxes\n        sb1 = session.create(\n            command=\"sleep\",\n            args=[\"infinity\"],\n            tags=[\"worker-1\"],\n        )\n        sb2 = session.create(\n            command=\"sleep\",\n            args=[\"infinity\"],\n            tags=[\"worker-2\"],\n        )\n\n        async with sb1, sb2:\n            print(f\"Sandbox 1: {sb1.sandbox_id}\")\n            print(f\"Sandbox 2: {sb2.sandbox_id}\")\n\n            # Run commands in parallel\n            r1, r2 = await asyncio.gather(\n                sb1.exec([\"echo\", \"from sandbox 1\"]),\n                sb2.exec([\"echo\", \"from sandbox 2\"]),\n            )\n\n            print(f\"sb1: {r1.stdout.strip()}\")\n            print(f\"sb2: {r2.stdout.strip()}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/parallel-sandboxes/#session-benefits","title":"Session Benefits","text":""},{"location":"examples/parallel-sandboxes/#shared-configuration","title":"Shared Configuration","text":"<p>All sandboxes created via <code>session.create()</code> inherit session defaults:</p> <pre><code>defaults = SandboxDefaults(\n    container_image=\"python:3.11\",\n    tags=(\"my-app\",),\n)\n\nasync with Sandbox.session(defaults) as session:\n    # Both sandboxes use python:3.11 and have \"my-app\" tag\n    sb1 = session.create(command=\"sleep\", args=[\"infinity\"])\n    sb2 = session.create(command=\"sleep\", args=[\"infinity\"])\n</code></pre>"},{"location":"examples/parallel-sandboxes/#automatic-cleanup","title":"Automatic Cleanup","text":"<p>The session tracks all sandboxes and stops any orphaned ones on exit:</p> <pre><code>async with Sandbox.session(defaults) as session:\n    sb1 = session.create(command=\"sleep\", args=[\"infinity\"])\n    async with sb1:\n        await sb1.exec([\"echo\", \"working\"])\n    # sb1 stopped by context manager\n\n    sb2 = session.create(command=\"sleep\", args=[\"infinity\"])\n    await sb2.start()\n    # Forgot to stop sb2!\n\n# Session cleanup stops sb2 automatically\n</code></pre>"},{"location":"examples/parallel-sandboxes/#parallel-function-execution","title":"Parallel Function Execution","text":"<p>Run multiple function calls in parallel:</p> <pre><code>async with Sandbox.session(defaults) as session:\n    @session.function()\n    def compute(n: int) -&gt; int:\n        import time\n        time.sleep(1)  # Simulate work\n        return n * n\n\n    # Run in parallel - total time ~1s instead of ~3s\n    results = await asyncio.gather(\n        compute(1),\n        compute(2),\n        compute(3),\n    )\n\n    print(results)  # (1, 4, 9)\n</code></pre>"}]}