{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Aviato SDK","text":"<p>Python client library for Aviato sandboxes - a remote code execution platform.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install aviato\n</code></pre>"},{"location":"#authentication","title":"Authentication","text":"<p>Set your API key:</p> <pre><code>export AVIATO_API_KEY=\"your-api-key\"\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from aviato import Sandbox\n\nwith Sandbox.run() as sandbox:\n    result = sandbox.exec([\"echo\", \"Hello, Aviato!\"]).result()\n    print(result.stdout)  # \"Hello, Aviato!\\n\"\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<p>Start the Tutorial \u2192</p> <p>The tutorial takes you from basics to advanced patterns:</p> <ol> <li>Your First Sandbox</li> <li>Configuring Sandboxes</li> <li>Running Commands</li> <li>Streaming Output</li> <li>Reading &amp; Writing Files</li> <li>Managing Multiple Sandboxes</li> <li>Remote Function Execution</li> <li>Cleanup &amp; Orphan Recovery</li> </ol> <p>Advanced:</p> <ul> <li>Async Patterns</li> <li>Managing Sandboxes</li> <li>Troubleshooting</li> </ul>"},{"location":"advanced/async-patterns/","title":"Async Patterns","text":"<p>Use <code>await</code> instead of <code>.result()</code>:</p> <pre><code>import asyncio\nfrom aviato import Sandbox\n\nasync def main():\n    async with Sandbox.run() as sandbox:\n        result = await sandbox.exec([\"echo\", \"hello\"])\n        print(result.stdout)\n\nasyncio.run(main())\n</code></pre> <p>Parallel with <code>asyncio.gather()</code>:</p> <pre><code>results = await asyncio.gather(\n    sandbox.exec([\"echo\", \"one\"]),\n    sandbox.exec([\"echo\", \"two\"]),\n)\n</code></pre> <p>Async streaming with <code>async for</code>:</p> <pre><code>process = sandbox.exec([\"bash\", \"-c\", \"for i in 1 2 3; do echo $i; sleep 1; done\"])\nasync for line in process.stdout:\n    print(line, end=\"\")\nresult = await process\n</code></pre> <p>Sync and async can be mixed - the SDK uses a background thread.</p>"},{"location":"advanced/managing-sandboxes/","title":"Managing Sandboxes","text":"<p>Find, attach to, adopt, and delete sandboxes.</p>"},{"location":"advanced/managing-sandboxes/#by-id","title":"By ID","text":"<pre><code>sandbox = Sandbox.from_id(\"sandbox-abc123\").result()\nresult = sandbox.exec([\"echo\", \"hello\"]).result()\n</code></pre>"},{"location":"advanced/managing-sandboxes/#by-tag","title":"By Tag","text":"<pre><code>sandboxes = Sandbox.list(tags=[\"my-app\"]).result()\nfor sb in sandboxes:\n    print(f\"{sb.sandbox_id}: {sb.status}\")\n</code></pre>"},{"location":"advanced/managing-sandboxes/#adopting-into-a-session","title":"Adopting into a Session","text":"<p>Add existing sandboxes to a session for automatic cleanup:</p> <pre><code>with Sandbox.session(defaults) as session:\n    # Find and adopt orphans\n    for sb in Sandbox.list(tags=[\"my-app\"]).result():\n        session.adopt(sb)\n\n    # Now they'll be cleaned up when session exits\n</code></pre>"},{"location":"advanced/managing-sandboxes/#deleting-by-id","title":"Deleting by ID","text":"<pre><code>Sandbox.delete(\"sandbox-abc123\").result()\n\n# Ignore if already deleted\nSandbox.delete(\"sandbox-abc123\", missing_ok=True).result()\n</code></pre>"},{"location":"advanced/troubleshooting/","title":"Troubleshooting","text":""},{"location":"advanced/troubleshooting/#authentication","title":"Authentication","text":"<p>401 errors: Set <code>AVIATO_API_KEY</code>, or <code>WANDB_API_KEY</code> + <code>WANDB_ENTITY_NAME</code>.</p>"},{"location":"advanced/troubleshooting/#common-errors","title":"Common Errors","text":"Exception Cause Fix <code>SandboxTimeoutError</code> Command exceeded timeout Increase <code>timeout_seconds</code> <code>SandboxExecutionError</code> Command failed with <code>check=True</code> Check <code>e.exec_result.stderr</code> <code>SandboxNotFoundError</code> Sandbox doesn't exist Use <code>missing_ok=True</code>"},{"location":"advanced/troubleshooting/#streaming","title":"Streaming","text":"<p>No output? Iterate <code>stdout</code> before <code>.result()</code>. Output buffered? Use <code>flush=True</code> or <code>python -u</code>.</p>"},{"location":"advanced/troubleshooting/#orphaned-sandboxes","title":"Orphaned Sandboxes","text":"<pre><code>for sb in Sandbox.list(tags=[\"my-app\"]).result():\n    sb.stop(missing_ok=True).result()\n</code></pre>"},{"location":"advanced/troubleshooting/#help","title":"Help","text":"<p>API Reference \u00b7 GitHub Issues</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#aviato","title":"aviato","text":"<p>A Python client library for Aviato sandboxes.</p>"},{"location":"api/#aviato.SandboxDefaults","title":"SandboxDefaults  <code>dataclass</code>","text":"<pre><code>SandboxDefaults(\n    container_image: str = DEFAULT_CONTAINER_IMAGE,\n    command: str = DEFAULT_COMMAND,\n    args: tuple[str, ...] = DEFAULT_ARGS,\n    base_url: str = DEFAULT_BASE_URL,\n    request_timeout_seconds: float = DEFAULT_REQUEST_TIMEOUT_SECONDS,\n    max_lifetime_seconds: float\n    | None = DEFAULT_MAX_LIFETIME_SECONDS,\n    temp_dir: str = DEFAULT_TEMP_DIR,\n    tags: tuple[str, ...] = tuple(),\n    runway_ids: tuple[str, ...] | None = None,\n    tower_ids: tuple[str, ...] | None = None,\n    resources: dict[str, Any] | None = None,\n)\n</code></pre> <p>Immutable configuration defaults for sandbox creation.</p> <p>All fields have sensible defaults. Override only what you need.</p> <p>There are two separate timeout concepts: - request_timeout_seconds: How long to wait for API responses (client-side) - max_lifetime_seconds: How long the sandbox runs before auto-termination (server-side)   If not set, the backend controls the default lifetime.</p> <p>Tags enable filtering and organizing sandboxes. They are propagated to the backend and can be used to query sandboxes by tag.</p> Example <pre><code>defaults = SandboxDefaults(\n    container_image=\"python:3.12\",\n    command=\"tail\",\n    args=(\"-f\", \"/dev/null\"),\n    request_timeout_seconds=60,\n    max_lifetime_seconds=3600,  # 1 hour sandbox lifetime\n    tags=(\"my-workload\", \"experiment-42\"),\n)\n</code></pre>"},{"location":"api/#aviato.SandboxDefaults.merge_tags","title":"merge_tags","text":"<pre><code>merge_tags(additional: list[str] | None) -&gt; list[str]\n</code></pre> <p>Combine default tags with additional tags.</p> <p>Tags from both sources are included. Order is: defaults first, then additional tags appended.</p>"},{"location":"api/#aviato.SandboxDefaults.with_overrides","title":"with_overrides","text":"<pre><code>with_overrides(**kwargs: Any) -&gt; SandboxDefaults\n</code></pre> <p>Create new defaults with some values overridden.</p>"},{"location":"api/#aviato.Sandbox","title":"Sandbox","text":"<pre><code>Sandbox(\n    *,\n    command: str | None = None,\n    args: list[str] | None = None,\n    defaults: SandboxDefaults | None = None,\n    container_image: str | None = None,\n    tags: list[str] | None = None,\n    base_url: str | None = None,\n    request_timeout_seconds: float | None = None,\n    max_lifetime_seconds: float | None = None,\n    runway_ids: list[str] | None = None,\n    tower_ids: list[str] | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n    _session: Session | None = None,\n)\n</code></pre> <p>Aviato sandbox client with sync/async hybrid API.</p> <p>All methods return immediately and can be used in both sync and async contexts. Operations are executed in a background event loop managed by _LoopManager.</p> <p>Examples:</p> <p>Factory method: <pre><code>sb = Sandbox.run(\"echo\", \"hello\")  # Returns immediately\nresult = sb.exec([\"echo\", \"more\"]).result()  # Block for result\nsb.stop().result()  # Block for completion\n</code></pre></p> <p>Context manager (recommended): <pre><code>with Sandbox.run(\"sleep\", \"infinity\") as sb:\n    result = sb.exec([\"echo\", \"hello\"]).result()\n# Automatically stopped on exit\n</code></pre></p> <p>Async context manager: <pre><code>async with Sandbox.run(\"sleep\", \"infinity\") as sb:\n    result = await sb.exec([\"echo\", \"hello\"])\n</code></pre></p> ATTRIBUTE DESCRIPTION <code>sandbox_id</code> <p>Unique identifier for this sandbox.</p> <p> TYPE: <code>str | None</code> </p> <code>status</code> <p>Cached status from last API call.</p> <p> TYPE: <code>SandboxStatus | None</code> </p> <code>tower_id</code> <p>Tower ID where sandbox is running.</p> <p> TYPE: <code>str | None</code> </p> <code>runway_id</code> <p>Runway ID for this sandbox.</p> <p> TYPE: <code>str | None</code> </p> <code>returncode</code> <p>Exit code if sandbox completed.</p> <p> TYPE: <code>int | None</code> </p> <code>started_at</code> <p>When sandbox started running.</p> <p> TYPE: <code>datetime | None</code> </p> <p>Initialize a sandbox (does not start it).</p> PARAMETER DESCRIPTION <code>command</code> <p>Optional command to run in the sandbox</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>args</code> <p>Optional arguments for the command</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>defaults</code> <p>Optional SandboxDefaults to apply</p> <p> TYPE: <code>SandboxDefaults | None</code> DEFAULT: <code>None</code> </p> <code>container_image</code> <p>Container image to use (default: python:3.11)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tags</code> <p>Optional tags for the sandbox</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>base_url</code> <p>Aviato API URL (default: AVIATO_BASE_URL env or localhost)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>request_timeout_seconds</code> <p>Timeout for API requests (client-side, default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_lifetime_seconds</code> <p>Max sandbox lifetime (server-side). If not set, the backend controls the default.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>runway_ids</code> <p>Optional list of runway IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>tower_ids</code> <p>Optional list of tower IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#aviato.Sandbox.sandbox_id","title":"sandbox_id  <code>property</code>","text":"<pre><code>sandbox_id: str | None\n</code></pre> <p>The unique sandbox ID, or None if not yet started.</p>"},{"location":"api/#aviato.Sandbox.returncode","title":"returncode  <code>property</code>","text":"<pre><code>returncode: int | None\n</code></pre> <p>Exit code if sandbox has completed, None if still running.</p> <p>Use wait() to block until the sandbox completes.</p>"},{"location":"api/#aviato.Sandbox.tower_id","title":"tower_id  <code>property</code>","text":"<pre><code>tower_id: str | None\n</code></pre> <p>Tower where sandbox is running, or None if not started.</p>"},{"location":"api/#aviato.Sandbox.runway_id","title":"runway_id  <code>property</code>","text":"<pre><code>runway_id: str | None\n</code></pre> <p>Runway where sandbox is running, or None if not started.</p>"},{"location":"api/#aviato.Sandbox.status","title":"status  <code>property</code>","text":"<pre><code>status: SandboxStatus | None\n</code></pre> <p>Last known status of the sandbox.</p> <p>This is the cached status from the most recent API interaction.</p> <p>Returns None only for sandboxes that haven't been started yet.</p> <p>Note: This value may be stale. Check status_updated_at for when it was last fetched. For guaranteed fresh status, use <code>await sandbox.get_status()</code> which always hits the API.</p>"},{"location":"api/#aviato.Sandbox.status_updated_at","title":"status_updated_at  <code>property</code>","text":"<pre><code>status_updated_at: datetime | None\n</code></pre> <p>Timestamp when status was last fetched from the API.</p> <p>Returns None only for sandboxes that haven't been started yet.</p>"},{"location":"api/#aviato.Sandbox.started_at","title":"started_at  <code>property</code>","text":"<pre><code>started_at: datetime | None\n</code></pre> <p>Timestamp when the sandbox was started.</p> <p>Populated after start() completes or when obtained via list()/from_id(). None only for sandboxes that haven't been started yet.</p>"},{"location":"api/#aviato.Sandbox.tower_group_id","title":"tower_group_id  <code>property</code>","text":"<pre><code>tower_group_id: str | None\n</code></pre> <p>Tower group ID where the sandbox is running.</p>"},{"location":"api/#aviato.Sandbox.run","title":"run  <code>classmethod</code>","text":"<pre><code>run(\n    *args: str,\n    container_image: str | None = None,\n    defaults: SandboxDefaults | None = None,\n    request_timeout_seconds: float | None = None,\n    max_lifetime_seconds: float | None = None,\n    tags: list[str] | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n) -&gt; Sandbox\n</code></pre> <p>Create and start a sandbox, return immediately once backend accepts.</p> <p>Does NOT wait for RUNNING status. Use .wait() to block until ready. If positional args are provided, the first is the command and the rest are its arguments. If no args are provided, uses defaults (tail -f /dev/null).</p> PARAMETER DESCRIPTION <code>*args</code> <p>Optional command and arguments (e.g., \"echo\", \"hello\", \"world\"). If omitted, uses default command from SandboxDefaults.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>container_image</code> <p>Container image to use</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>defaults</code> <p>Optional SandboxDefaults to apply</p> <p> TYPE: <code>SandboxDefaults | None</code> DEFAULT: <code>None</code> </p> <code>request_timeout_seconds</code> <p>Timeout for API requests (client-side)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_lifetime_seconds</code> <p>Max sandbox lifetime (server-side)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>tags</code> <p>Optional tags for the sandbox</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>A Sandbox instance (start request sent, but may still be starting)</p> Example <pre><code># Using defaults (tail -f /dev/null)\nsb = Sandbox.run()\n\n# Fire and forget style\nsb = Sandbox.run(\"echo\", \"hello\")\n# sb.sandbox_id is set, but sandbox may still be starting\n\n# Wait for ready if needed\nsb = Sandbox.run(\"sleep\", \"infinity\").wait()\nresult = sb.exec([\"echo\", \"hello\"]).result()\n\n# Or use context manager for automatic cleanup\nwith Sandbox.run(\"sleep\", \"infinity\") as sb:\n    result = sb.exec([\"echo\", \"hello\"]).result()\n</code></pre>"},{"location":"api/#aviato.Sandbox.session","title":"session  <code>classmethod</code>","text":"<pre><code>session(defaults: SandboxDefaults | None = None) -&gt; Session\n</code></pre> <p>Create a session for managing multiple sandboxes.</p> <p>Sessions provide: - Shared configuration via defaults - Automatic cleanup of orphaned sandboxes - Function execution via @session.function() decorator</p> PARAMETER DESCRIPTION <code>defaults</code> <p>Optional defaults to apply to sandboxes created via session</p> <p> TYPE: <code>SandboxDefaults | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Session</code> <p>A Session instance</p> Example <pre><code>session = Sandbox.session(defaults)\nsb = session.create(command=\"sleep\", args=[\"infinity\"])\n\n@session.function()\ndef compute(x, y):\n    return x + y\n\nawait session.close()\n</code></pre>"},{"location":"api/#aviato.Sandbox.list","title":"list  <code>classmethod</code>","text":"<pre><code>list(\n    *,\n    tags: list[str] | None = None,\n    status: str | None = None,\n    runway_ids: list[str] | None = None,\n    tower_ids: list[str] | None = None,\n    base_url: str | None = None,\n    timeout_seconds: float | None = None,\n) -&gt; OperationRef[list[Sandbox]]\n</code></pre> <p>List existing sandboxes with optional filters.</p> <p>Returns OperationRef that resolves to Sandbox instances usable for operations like exec(), stop(), get_status(), read_file(), write_file().</p> PARAMETER DESCRIPTION <code>tags</code> <p>Filter by tags (sandboxes must have ALL specified tags)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>Filter by status (\"running\", \"completed\", \"failed\", etc.)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>runway_ids</code> <p>Filter by runway IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>tower_ids</code> <p>Filter by tower IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>base_url</code> <p>Override API URL (default: AVIATO_BASE_URL env or default)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout_seconds</code> <p>Request timeout (default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OperationRef[list[Sandbox]]</code> <p>OperationRef[list[Sandbox]]: Use .result() to block for results,</p> <code>OperationRef[list[Sandbox]]</code> <p>or await directly in async contexts.</p> Example <pre><code># Sync usage\nsandboxes = Sandbox.list(tags=[\"my-batch-job\"]).result()\nfor sb in sandboxes:\n    print(f\"{sb.sandbox_id}: {sb.status}\")\n    sb.stop().result()\n\n# Async usage\nsandboxes = await Sandbox.list(status=\"running\")\nfor sb in sandboxes:\n    result = await sb.exec([\"echo\", \"hello\"])\n</code></pre>"},{"location":"api/#aviato.Sandbox.from_id","title":"from_id  <code>classmethod</code>","text":"<pre><code>from_id(\n    sandbox_id: str,\n    *,\n    base_url: str | None = None,\n    timeout_seconds: float | None = None,\n) -&gt; OperationRef[Sandbox]\n</code></pre> <p>Attach to an existing sandbox by ID.</p> <p>Creates a Sandbox instance connected to an existing sandbox, allowing operations like exec(), stop(), get_status(), etc.</p> PARAMETER DESCRIPTION <code>sandbox_id</code> <p>The ID of the existing sandbox</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>Override API URL (default: AVIATO_BASE_URL env or default)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout_seconds</code> <p>Request timeout (default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OperationRef[Sandbox]</code> <p>OperationRef[Sandbox]: Use .result() to block for the Sandbox instance,</p> <code>OperationRef[Sandbox]</code> <p>or await directly in async contexts.</p> RAISES DESCRIPTION <code>SandboxNotFoundError</code> <p>If sandbox doesn't exist</p> Example <pre><code># Sync usage\nsb = Sandbox.from_id(\"sandbox-abc123\").result()\nresult = sb.exec([\"python\", \"-c\", \"print('hello')\"]).result()\nsb.stop().result()\n\n# Async usage\nsb = await Sandbox.from_id(\"sandbox-abc123\")\nresult = await sb.exec([\"python\", \"-c\", \"print('hello')\"])\n</code></pre>"},{"location":"api/#aviato.Sandbox.delete","title":"delete  <code>classmethod</code>","text":"<pre><code>delete(\n    sandbox_id: str,\n    *,\n    base_url: str | None = None,\n    timeout_seconds: float | None = None,\n    missing_ok: bool = False,\n) -&gt; OperationRef[None]\n</code></pre> <p>Delete a sandbox by ID without creating a Sandbox instance.</p> <p>This is a convenience method for cleanup scenarios where you don't need to perform other operations on the sandbox.</p> PARAMETER DESCRIPTION <code>sandbox_id</code> <p>The sandbox ID to delete</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>Override API URL (default: AVIATO_BASE_URL env or default)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout_seconds</code> <p>Request timeout (default: 300s)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>missing_ok</code> <p>If True, suppress SandboxNotFoundError when sandbox doesn't exist.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>OperationRef[None]</code> <p>OperationRef[None]: Use .result() to block until complete.</p> <code>OperationRef[None]</code> <p>Raises SandboxNotFoundError if not found (unless missing_ok=True),</p> <code>OperationRef[None]</code> <p>SandboxError if deletion failed.</p> RAISES DESCRIPTION <code>SandboxNotFoundError</code> <p>If sandbox doesn't exist and missing_ok=False</p> <code>SandboxError</code> <p>If deletion failed for other reasons</p> Example <pre><code># Sync usage\nSandbox.delete(\"sandbox-abc123\").result()\n\n# Ignore if already deleted\nSandbox.delete(\"sandbox-abc123\", missing_ok=True).result()\n\n# Async usage\nawait Sandbox.delete(\"sandbox-abc123\")\n</code></pre>"},{"location":"api/#aviato.Sandbox.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; SandboxStatus\n</code></pre> <p>Get the current status of the sandbox from the backend.</p> RETURNS DESCRIPTION <code>SandboxStatus</code> <p>SandboxStatus enum value</p> RAISES DESCRIPTION <code>SandboxNotRunningError</code> <p>If sandbox has not been started</p> Example <pre><code>sb = Sandbox.run(\"sleep\", \"10\")\nstatus = sb.get_status()\nprint(f\"Sandbox is {status}\")  # SandboxStatus.PENDING or RUNNING\n</code></pre>"},{"location":"api/#aviato.Sandbox.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Send StartSandbox to backend, return once accepted.</p> <p>Does NOT wait for RUNNING status. Use wait() to block until ready.</p> Example <pre><code>sandbox = Sandbox(command=\"sleep\", args=[\"infinity\"])\nsandbox.start()\nprint(f\"Started sandbox: {sandbox.sandbox_id}\")\nsandbox.wait()  # Block until RUNNING\n</code></pre>"},{"location":"api/#aviato.Sandbox.wait","title":"wait","text":"<pre><code>wait(timeout: float | None = None) -&gt; Sandbox\n</code></pre> <p>Block until sandbox reaches RUNNING or a terminal state.</p> <p>Returns when sandbox is RUNNING or has already completed (COMPLETED/UNSPECIFIED).</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Maximum seconds to wait. None means use default timeout.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>Self for method chaining. Check .status to determine final state.</p> RAISES DESCRIPTION <code>SandboxFailedError</code> <p>If sandbox fails to start</p> <code>SandboxTerminatedError</code> <p>If sandbox was terminated externally</p> <code>SandboxTimeoutError</code> <p>If timeout expires</p> Example <pre><code>sb = Sandbox.run(\"sleep\", \"infinity\").wait()\nresult = sb.exec([\"echo\", \"ready\"]).result()\n</code></pre>"},{"location":"api/#aviato.Sandbox.wait_until_complete","title":"wait_until_complete","text":"<pre><code>wait_until_complete(\n    timeout: float | None = None,\n    *,\n    raise_on_termination: bool = True,\n) -&gt; Sandbox\n</code></pre> <p>Block until sandbox reaches terminal state (COMPLETED/FAILED/TERMINATED).</p> <p>After this returns successfully, returncode will be available.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Maximum seconds to wait. None means use default timeout.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>raise_on_termination</code> <p>If True (default), raises SandboxTerminatedError if sandbox was terminated externally.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>Self for method chaining.</p> RAISES DESCRIPTION <code>SandboxTimeoutError</code> <p>If timeout expires</p> <code>SandboxTerminatedError</code> <p>If sandbox was terminated (and raise_on_termination=True)</p> <code>SandboxFailedError</code> <p>If sandbox failed</p> Example <pre><code>sb = Sandbox.run(\"python\", \"-c\", \"print('done')\")\nsb.wait_until_complete()\nprint(f\"Exit code: {sb.returncode}\")\n</code></pre>"},{"location":"api/#aviato.Sandbox.stop","title":"stop","text":"<pre><code>stop(\n    *,\n    snapshot_on_stop: bool = False,\n    graceful_shutdown_seconds: float = DEFAULT_GRACEFUL_SHUTDOWN_SECONDS,\n    missing_ok: bool = False,\n) -&gt; OperationRef[None]\n</code></pre> <p>Stop sandbox, return OperationRef immediately.</p> <p>The sandbox is deregistered from its session regardless of whether the stop was successful, since the sandbox is no longer usable.</p> PARAMETER DESCRIPTION <code>snapshot_on_stop</code> <p>If True, capture sandbox state before shutdown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>graceful_shutdown_seconds</code> <p>Time to wait for graceful shutdown.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_GRACEFUL_SHUTDOWN_SECONDS</code> </p> <code>missing_ok</code> <p>If True, suppress SandboxNotFoundError when sandbox doesn't exist.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>OperationRef[None]</code> <p>OperationRef[None]: Use .result() to block until complete.</p> <code>OperationRef[None]</code> <p>Raises SandboxError on failure, SandboxNotFoundError if not found</p> <code>OperationRef[None]</code> <p>(unless missing_ok=True).</p> Example <pre><code>sb.stop().result()  # Block until stopped\n\n# Ignore if already deleted\nsb.stop(missing_ok=True).result()\n</code></pre>"},{"location":"api/#aviato.Sandbox.exec","title":"exec","text":"<pre><code>exec(\n    command: Sequence[str],\n    *,\n    cwd: str | None = None,\n    check: bool = False,\n    timeout_seconds: float | None = None,\n) -&gt; Process\n</code></pre> <p>Execute command, return Process immediately.</p> <p>Note: If sandbox is not yet RUNNING, this method waits for it first. The timeout_seconds parameter only applies to command execution, not to the initial wait for RUNNING status.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command and arguments to execute</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>cwd</code> <p>Working directory for command execution. Must be an absolute path. When specified, the command is wrapped with a shell cd.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>check</code> <p>If True, raise SandboxExecutionError on non-zero returncode</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout_seconds</code> <p>Timeout for command execution (after sandbox is RUNNING). Does not include time waiting for sandbox to reach RUNNING status.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>Process handle with streaming stdout/stderr. Call .result() to block</p> <code>Process</code> <p>for the final ProcessResult, or iterate over .stdout/.stderr for</p> <code>Process</code> <p>real-time output.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If command is empty or cwd is invalid (empty or relative path)</p> Example <pre><code># Get result directly\nprocess = sb.exec([\"echo\", \"hello\"])\nresult = process.result()\nprint(result.stdout)\n\n# With working directory\nresult = sb.exec([\"ls\", \"-la\"], cwd=\"/app\").result()\n\n# Stream output in real-time\nprocess = sb.exec([\"python\", \"script.py\"])\nfor line in process.stdout:\n    print(line)\nresult = process.result()\n\n# Async usage\nresult = await sb.exec([\"echo\", \"hello\"])\n</code></pre>"},{"location":"api/#aviato.Sandbox.read_file","title":"read_file","text":"<pre><code>read_file(\n    filepath: str, *, timeout_seconds: float | None = None\n) -&gt; OperationRef[bytes]\n</code></pre> <p>Read file from sandbox, return OperationRef immediately.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to file in sandbox</p> <p> TYPE: <code>str</code> </p> <code>timeout_seconds</code> <p>Timeout for the operation</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OperationRef[bytes]</code> <p>OperationRef[bytes]: Use .result() to block and retrieve contents.</p> Example <pre><code>data = sb.read_file(\"/output/result.txt\").result()\n</code></pre>"},{"location":"api/#aviato.Sandbox.write_file","title":"write_file","text":"<pre><code>write_file(\n    filepath: str,\n    contents: bytes,\n    *,\n    timeout_seconds: float | None = None,\n) -&gt; OperationRef[None]\n</code></pre> <p>Write file to sandbox, return OperationRef immediately.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to file in sandbox</p> <p> TYPE: <code>str</code> </p> <code>contents</code> <p>File contents as bytes</p> <p> TYPE: <code>bytes</code> </p> <code>timeout_seconds</code> <p>Timeout for the operation</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OperationRef[None]</code> <p>OperationRef[None]: Use .result() to block until complete.</p> Example <pre><code>sb.write_file(\"/input/data.txt\", b\"content\").result()\n</code></pre>"},{"location":"api/#aviato.SandboxStatus","title":"SandboxStatus","text":"<p>Sandbox status values.</p>"},{"location":"api/#aviato.SandboxStatus.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(proto_status: int) -&gt; SandboxStatus\n</code></pre> <p>Convert protobuf status enum to SandboxStatus.</p>"},{"location":"api/#aviato.SandboxStatus.to_proto","title":"to_proto","text":"<pre><code>to_proto() -&gt; int\n</code></pre> <p>Convert SandboxStatus to protobuf enum</p>"},{"location":"api/#aviato.Session","title":"Session","text":"<pre><code>Session(defaults: SandboxDefaults | None = None)\n</code></pre> <p>Manages sandbox lifecycle and provides function execution.</p> <p>Use a session when: - Creating multiple sandboxes with shared configuration - Executing Python functions in sandboxes - You want automatic cleanup of orphaned sandboxes</p> Example <pre><code>defaults = SandboxDefaults(container_image=\"python:3.11\")\n\n# Sync context manager\nwith Session(defaults) as session:\n    # Create and start sandboxes with session defaults\n    sb1 = session.sandbox(command=\"sleep\", args=[\"infinity\"])\n    sb2 = session.sandbox(command=\"sleep\", args=[\"infinity\"])\n\n    # Execute commands\n    result = sb1.exec([\"echo\", \"hello\"]).result()\n\n    # Execute functions in sandboxes\n    @session.function()\n    def compute(x: int, y: int) -&gt; int:\n        return x + y\n\n    result = compute.remote(2, 3).result()  # Returns OperationRef\n    print(result)  # 5\n\n# Session automatically cleans up all sandboxes on exit\n\n# Async context manager also supported\nasync with Session(defaults) as session:\n    sb = session.sandbox(command=\"sleep\", args=[\"infinity\"])\n    result = await sb.exec([\"echo\", \"hello\"])\n</code></pre>"},{"location":"api/#aviato.Session.sandbox_count","title":"sandbox_count  <code>property</code>","text":"<pre><code>sandbox_count: int\n</code></pre> <p>Number of sandboxes currently tracked by this session.</p>"},{"location":"api/#aviato.Session.close","title":"close","text":"<pre><code>close() -&gt; OperationRef[None]\n</code></pre> <p>Stop all managed sandboxes, return OperationRef immediately.</p> RETURNS DESCRIPTION <code>OperationRef[None]</code> <p>OperationRef[None]: Use .result() to block until all sandboxes stopped.</p> RAISES DESCRIPTION <code>SandboxError</code> <p>If one or more running sandboxes failed to stop.</p> Example <pre><code>session.close().result()  # Block until all sandboxes stopped\n</code></pre>"},{"location":"api/#aviato.Session.sandbox","title":"sandbox","text":"<pre><code>sandbox(\n    *,\n    command: str | None = None,\n    args: list[str] | None = None,\n    container_image: str | None = None,\n    tags: list[str] | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: list[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: list[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n) -&gt; Sandbox\n</code></pre> <p>Create and start a sandbox with session defaults, return immediately.</p> <p>This is the recommended way to create sandboxes in the sync API. The sandbox is created and started, returning immediately once the backend accepts the start request (does NOT wait for RUNNING status).</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to run in sandbox</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>args</code> <p>Arguments for the command</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>container_image</code> <p>Container image to use</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tags</code> <p>Tags for the sandbox (merged with session defaults)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Sandbox</code> <p>A started Sandbox instance. Use .wait() to block until RUNNING.</p> RAISES DESCRIPTION <code>SandboxError</code> <p>If the session has been closed.</p> Example <pre><code>with Session(defaults) as session:\n    sb = session.sandbox(command=\"sleep\", args=[\"infinity\"])\n    sb.wait()  # Optional: block until RUNNING\n    result = sb.exec([\"echo\", \"hello\"]).result()\n</code></pre>"},{"location":"api/#aviato.Session.list","title":"list","text":"<pre><code>list(\n    *,\n    tags: list[str] | None = None,\n    status: str | None = None,\n    runway_ids: list[str] | None = None,\n    tower_ids: list[str] | None = None,\n    adopt: bool = False,\n) -&gt; OperationRef[list[Sandbox]]\n</code></pre> <p>List sandboxes, optionally adopting them into this session.</p> <p>Automatically includes the session's default tags in the filter. This makes it easy to find sandboxes created by this session or a previous run with the same defaults.</p> PARAMETER DESCRIPTION <code>tags</code> <p>Additional tags to filter by (merged with session's default tags)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>Filter by status</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>runway_ids</code> <p>Filter by runway IDs (defaults to session's runway_ids if set)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>tower_ids</code> <p>Filter by tower IDs (defaults to session's tower_ids if set)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>adopt</code> <p>If True, register discovered sandboxes with this session    so they are stopped when the session closes</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>OperationRef[list[Sandbox]]</code> <p>OperationRef[list[Sandbox]]: Use .result() to block for results,</p> <code>OperationRef[list[Sandbox]]</code> <p>or await directly in async contexts.</p> Example <pre><code># Session defaults include a tag for this application/run\ndefaults = SandboxDefaults(tags=(\"my-app\", \"run-abc123\"))\n\nwith Session(defaults) as session:\n    # Sync usage - automatically filters by [\"my-app\", \"run-abc123\"]\n    orphans = session.list(adopt=True).result()\n\n    # Can add additional filters\n    running = session.list(status=\"running\").result()\n\n# Async usage\nasync with Session(defaults) as session:\n    orphans = await session.list(adopt=True)\n</code></pre>"},{"location":"api/#aviato.Session.from_id","title":"from_id","text":"<pre><code>from_id(\n    sandbox_id: str, *, adopt: bool = True\n) -&gt; OperationRef[Sandbox]\n</code></pre> <p>Attach to an existing sandbox, optionally adopting it into this session.</p> PARAMETER DESCRIPTION <code>sandbox_id</code> <p>The ID of the existing sandbox</p> <p> TYPE: <code>str</code> </p> <code>adopt</code> <p>If True (default), register the sandbox with this session</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>OperationRef[Sandbox]</code> <p>OperationRef[Sandbox]: Use .result() to block for the Sandbox instance,</p> <code>OperationRef[Sandbox]</code> <p>or await directly in async contexts.</p> Example <pre><code>with Session(defaults) as session:\n    # Sync usage - reconnect to a sandbox\n    sb = session.from_id(\"sandbox-abc123\").result()\n    result = sb.exec([\"echo\", \"hello\"]).result()\n# sb is stopped when session exits\n\n# Async usage\nasync with Session(defaults) as session:\n    sb = await session.from_id(\"sandbox-abc123\")\n    result = await sb.exec([\"echo\", \"hello\"])\n</code></pre>"},{"location":"api/#aviato.Session.adopt","title":"adopt","text":"<pre><code>adopt(sandbox: Sandbox) -&gt; None\n</code></pre> <p>Adopt an existing Sandbox instance into this session for cleanup tracking.</p> <p>Use this when you have a Sandbox from Sandbox.list() or Sandbox.from_id() that you want to be automatically stopped when the session closes.</p> PARAMETER DESCRIPTION <code>sandbox</code> <p>A Sandbox instance to track</p> <p> TYPE: <code>Sandbox</code> </p> RAISES DESCRIPTION <code>SandboxError</code> <p>If the session is closed</p> <code>ValueError</code> <p>If the sandbox has no sandbox_id</p> Example <pre><code>with Session(defaults) as session:\n    # Get sandboxes via class method\n    sandboxes = Sandbox.list(tags=[\"my-job\"]).result()\n\n    # Adopt them into the session\n    for sb in sandboxes:\n        session.adopt(sb)\n\n    # Now they'll be stopped when session closes\n</code></pre>"},{"location":"api/#aviato.Session.function","title":"function","text":"<pre><code>function(\n    *,\n    container_image: str | None = None,\n    serialization: Serialization = JSON,\n    temp_dir: str | None = None,\n    resources: dict[str, Any] | None = None,\n    mounted_files: Sequence[dict[str, Any]] | None = None,\n    s3_mount: dict[str, Any] | None = None,\n    ports: Sequence[dict[str, Any]] | None = None,\n    service: dict[str, Any] | None = None,\n    max_timeout_seconds: int | None = None,\n) -&gt; Callable[[Callable[P, R]], RemoteFunction[P, R]]\n</code></pre> <p>Decorator to execute a Python function in a sandbox.</p> <p>Each function call creates an ephemeral sandbox, executes the function, and returns the result. The sandbox is automatically cleaned up.</p> <p>The decorated function must be synchronous. Async functions are not supported.</p> PARAMETER DESCRIPTION <code>container_image</code> <p>Override session's default image for this function</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>serialization</code> <p>How to serialize arguments and return values. Defaults to JSON for safety. Use PICKLE for complex types, but only in trusted environments.</p> <p> TYPE: <code>Serialization</code> DEFAULT: <code>JSON</code> </p> <code>temp_dir</code> <p>Override temp directory for payload/result files in sandbox. Defaults to session default. Created if missing.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>resources</code> <p>Resource requests (CPU, memory, GPU)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>mounted_files</code> <p>Files to mount into the sandbox</p> <p> TYPE: <code>Sequence[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>s3_mount</code> <p>S3 bucket mount configuration</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>ports</code> <p>Port mappings for the sandbox</p> <p> TYPE: <code>Sequence[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>service</code> <p>Service configuration for network access</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>max_timeout_seconds</code> <p>Maximum timeout for sandbox operations</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], RemoteFunction[P, R]]</code> <p>A decorator that wraps a function as a RemoteFunction</p> Example <pre><code>with Session(defaults) as session:\n    @session.function()\n    def compute(x: int, y: int) -&gt; int:\n        return x + y\n\n    @session.function(serialization=Serialization.PICKLE)\n    def process_complex(data: MyClass) -&gt; MyClass:\n        return data.transform()\n\n    # Call .remote() to execute in sandbox\n    ref = compute.remote(2, 3)  # Returns OperationRef immediately\n    result = ref.result()       # Block for result\n    print(result)  # 5\n\n    # Or use await in async context\n    result = await compute.remote(2, 3)\n\n    # Execute locally for testing\n    result = compute.local(2, 3)\n\n    # Map over multiple inputs in parallel\n    refs = compute.map([(1, 2), (3, 4), (5, 6)])\n    results = [ref.result() for ref in refs]\n</code></pre>"},{"location":"api/#aviato.OperationRef","title":"OperationRef","text":"<pre><code>OperationRef(future: Future[T])\n</code></pre> <p>Generic ref for async operations with lazy result retrieval.</p> <p>OperationRef wraps a concurrent.futures.Future and provides a unified interface for both synchronous and asynchronous result retrieval. This enables the sync/async hybrid API where operations return immediately and results are retrieved lazily.</p>                CLASS TYPE PARAMETER              DESCRIPTION <code>T</code> <p>The type of the result this operation will return.</p> <p> </p> <p>Examples:</p> <p>Synchronous usage: <pre><code>ref = sandbox.read_file(\"/path/to/file\")  # Returns OperationRef[bytes]\ndata = ref.result()  # Block until complete\n</code></pre></p> <p>With timeout: <pre><code>try:\n    data = ref.result(timeout=5.0)\nexcept concurrent.futures.TimeoutError:\n    print(\"Operation timed out\")\n</code></pre></p> <p>Async usage: <pre><code>data = await ref  # Awaitable in async context\n</code></pre></p> <p>Initialize with a concurrent.futures.Future.</p> PARAMETER DESCRIPTION <code>future</code> <p>The underlying future that will contain the result.</p> <p> TYPE: <code>Future[T]</code> </p>"},{"location":"api/#aviato.OperationRef.result","title":"result","text":"<pre><code>result(timeout: float | None = None) -&gt; T\n</code></pre> <p>Block until the result is ready and return it.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Maximum seconds to wait. None means wait forever.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>T</code> <p>The result of the operation.</p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If timeout expires before completion.</p> <code>CancelledError</code> <p>If the operation was cancelled.</p> <code>Exception</code> <p>Any exception raised by the operation.</p>"},{"location":"api/#aviato.Process","title":"Process","text":"<pre><code>Process(\n    future: Future[ProcessResult],\n    command: list[str],\n    stdout: StreamReader,\n    stderr: StreamReader,\n)\n</code></pre> <p>Handle for a running process with streaming stdout/stderr.</p> <p>Process inherits from OperationRef[ProcessResult] and adds streaming capabilities and process-specific methods. It wraps an async operation that executes a command in a sandbox.</p> <p>The process's output streams (stdout, stderr) can be iterated either synchronously or asynchronously. The result() method blocks until completion and returns the full ProcessResult.</p> ATTRIBUTE DESCRIPTION <code>stdout</code> <p>StreamReader for standard output</p> <p> </p> <code>stderr</code> <p>StreamReader for standard error</p> <p> </p> <p>Examples:</p> <p>Basic execution with result: <pre><code>process = sandbox.exec([\"echo\", \"hello\"])\nresult = process.result()\nprint(result.stdout)  # hello\n</code></pre></p> <p>Streaming output: <pre><code>process = sandbox.exec([\"python\", \"-c\", \"print('line1'); print('line2')\"])\nfor line in process.stdout:\n    print(f\"Got: {line}\")\n</code></pre></p> <p>Async streaming: <pre><code>async for line in process.stdout:\n    print(f\"Got: {line}\")\n</code></pre></p> <p>Waiting with timeout: <pre><code>try:\n    exit_code = process.wait(timeout=10.0)\nexcept concurrent.futures.TimeoutError:\n    process.cancel()\n</code></pre></p> <p>Initialize with a future and stream readers.</p> PARAMETER DESCRIPTION <code>future</code> <p>Future that will contain the ProcessResult when complete.</p> <p> TYPE: <code>Future[ProcessResult]</code> </p> <code>command</code> <p>The command being executed.</p> <p> TYPE: <code>list[str]</code> </p> <code>stdout</code> <p>StreamReader for stdout.</p> <p> TYPE: <code>StreamReader</code> </p> <code>stderr</code> <p>StreamReader for stderr.</p> <p> TYPE: <code>StreamReader</code> </p>"},{"location":"api/#aviato.Process.returncode","title":"returncode  <code>property</code>","text":"<pre><code>returncode: int | None\n</code></pre> <p>The process exit code, or None if not yet complete.</p>"},{"location":"api/#aviato.Process.command","title":"command  <code>property</code>","text":"<pre><code>command: list[str]\n</code></pre> <p>The command that was executed.</p>"},{"location":"api/#aviato.Process.poll","title":"poll","text":"<pre><code>poll() -&gt; int | None\n</code></pre> <p>Check if the process has completed without blocking.</p> RETURNS DESCRIPTION <code>int | None</code> <p>The exit code if the process has completed, None otherwise.</p>"},{"location":"api/#aviato.Process.wait","title":"wait","text":"<pre><code>wait(timeout: float | None = None) -&gt; int\n</code></pre> <p>Block until the process completes.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Maximum seconds to wait. None means wait forever.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The process exit code.</p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If timeout expires.</p> <code>CancelledError</code> <p>If the operation was cancelled.</p> <code>Exception</code> <p>Any exception from the execution.</p>"},{"location":"api/#aviato.Process.result","title":"result","text":"<pre><code>result(timeout: float | None = None) -&gt; ProcessResult\n</code></pre> <p>Block until complete and return the full ProcessResult.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Maximum seconds to wait. None means wait forever.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProcessResult</code> <p>The ProcessResult containing stdout, stderr, and exit code.</p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If timeout expires.</p> <code>CancelledError</code> <p>If the operation was cancelled.</p> <code>Exception</code> <p>Any exception from the execution.</p>"},{"location":"api/#aviato.Process.cancel","title":"cancel","text":"<pre><code>cancel() -&gt; bool\n</code></pre> <p>Attempt to cancel the process.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if successfully cancelled, False otherwise.</p>"},{"location":"api/#aviato.ProcessResult","title":"ProcessResult  <code>dataclass</code>","text":"<pre><code>ProcessResult(\n    stdout: str,\n    stderr: str,\n    returncode: int,\n    stdout_bytes: bytes = b\"\",\n    stderr_bytes: bytes = b\"\",\n    command: list[str] = list(),\n)\n</code></pre> <p>Result from a completed streaming exec operation.</p> <p>Contains both the raw bytes and decoded strings for stdout/stderr, along with the exit code and original command.</p> ATTRIBUTE DESCRIPTION <code>stdout</code> <p>Decoded stdout as UTF-8 string</p> <p> TYPE: <code>str</code> </p> <code>stderr</code> <p>Decoded stderr as UTF-8 string</p> <p> TYPE: <code>str</code> </p> <code>returncode</code> <p>Exit code from the command (0 = success)</p> <p> TYPE: <code>int</code> </p> <code>stdout_bytes</code> <p>Raw stdout bytes</p> <p> TYPE: <code>bytes</code> </p> <code>stderr_bytes</code> <p>Raw stderr bytes</p> <p> TYPE: <code>bytes</code> </p> <code>command</code> <p>The command that was executed</p> <p> TYPE: <code>list[str]</code> </p> <p>Examples:</p> <pre><code>result = process.result()\nif result.returncode == 0:\n    print(result.stdout)\nelse:\n    print(f\"Error: {result.stderr}\")\n</code></pre>"},{"location":"api/#aviato.Serialization","title":"Serialization","text":"<p>Serialization modes for sandbox function execution.</p>"},{"location":"api/#aviato.StreamReader","title":"StreamReader","text":"<pre><code>StreamReader(\n    queue: Queue[str | None], loop_manager: _LoopManager\n)\n</code></pre> <p>Sync and async iterable for streaming output.</p> <p>StreamReader wraps an asyncio.Queue and provides both synchronous and asynchronous iteration interfaces. This enables streaming output to be consumed in both sync and async contexts.</p> <p>The stream uses None as a sentinel value to signal end-of-stream.</p> <p>Examples:</p> <p>Synchronous iteration: <pre><code>for line in process.stdout:\n    print(line)\n</code></pre></p> <p>Asynchronous iteration: <pre><code>async for line in process.stdout:\n    print(line)\n</code></pre></p> <p>Initialize with a queue and loop manager.</p> PARAMETER DESCRIPTION <code>queue</code> <p>The asyncio.Queue to read from.</p> <p> TYPE: <code>Queue[str | None]</code> </p> <code>loop_manager</code> <p>The _LoopManager for executing async operations.</p> <p> TYPE: <code>_LoopManager</code> </p>"},{"location":"api/#aviato.AsyncFunctionError","title":"AsyncFunctionError","text":"<p>Raised when an async function is passed to @session.function().</p> <p>Async functions are not supported because the sandbox executes Python synchronously. The decorated function must be a regular (sync) function.</p>"},{"location":"api/#aviato.AviatoAuthenticationError","title":"AviatoAuthenticationError","text":"<p>Raised when authentication fails.</p>"},{"location":"api/#aviato.AviatoError","title":"AviatoError","text":"<p>Base exception for all Aviato operations.</p>"},{"location":"api/#aviato.FunctionError","title":"FunctionError","text":"<p>Base exception for function execution operations.</p>"},{"location":"api/#aviato.FunctionSerializationError","title":"FunctionSerializationError","text":"<p>Raised when arguments, referenced globals, or closures cannot be serialized.</p>"},{"location":"api/#aviato.SandboxError","title":"SandboxError","text":"<p>Base exception for sandbox operations.</p>"},{"location":"api/#aviato.SandboxExecutionError","title":"SandboxExecutionError","text":"<pre><code>SandboxExecutionError(\n    message: str,\n    *,\n    exec_result: ProcessResult | None = None,\n    exception_type: str | None = None,\n    exception_message: str | None = None,\n)\n</code></pre> <p>Raised when command execution fails inside a sandbox.</p> <p>Access execution details via exec_result</p>"},{"location":"api/#aviato.SandboxFailedError","title":"SandboxFailedError","text":"<p>Raised when a sandbox fails to start or encounters a fatal error.</p>"},{"location":"api/#aviato.SandboxFileError","title":"SandboxFileError","text":"<pre><code>SandboxFileError(\n    message: str, *, filepath: str | None = None\n)\n</code></pre> <p>Raised when a file operation fails in the sandbox.</p> <p>This is a sandbox infrastructure error, not a user code error. Inherits from SandboxError since it's a sandbox operation failure.</p>"},{"location":"api/#aviato.SandboxNotFoundError","title":"SandboxNotFoundError","text":"<pre><code>SandboxNotFoundError(\n    message: str, *, sandbox_id: str | None = None\n)\n</code></pre> <p>Raised when a sandbox is not found (e.g., already deleted).</p>"},{"location":"api/#aviato.SandboxNotRunningError","title":"SandboxNotRunningError","text":"<p>Raised when an operation requires a running sandbox.</p>"},{"location":"api/#aviato.SandboxTerminatedError","title":"SandboxTerminatedError","text":"<p>Raised when a sandbox was terminated externally.</p>"},{"location":"api/#aviato.SandboxTimeoutError","title":"SandboxTimeoutError","text":"<p>Raised when a sandbox operation times out.</p>"},{"location":"api/#aviato.WandbAuthError","title":"WandbAuthError","text":"<p>Raised when W&amp;B authentication is misconfigured.</p>"},{"location":"api/#aviato.results","title":"results","text":"<pre><code>results(ref: OperationRef[T]) -&gt; T\n</code></pre><pre><code>results(refs: Sequence[OperationRef[T]]) -&gt; list[T]\n</code></pre> <pre><code>results(\n    refs: OperationRef[T] | Sequence[OperationRef[T]],\n) -&gt; T | list[T]\n</code></pre> <p>Block for one or more OperationRefs and return results.</p> <p>This is a convenience function for retrieving results from OperationRefs. For a single ref, returns the result directly. For a sequence of refs, returns a list of results in the same order.</p> PARAMETER DESCRIPTION <code>refs</code> <p>A single OperationRef or a sequence of OperationRefs.</p> <p> TYPE: <code>OperationRef[T] | Sequence[OperationRef[T]]</code> </p> RETURNS DESCRIPTION <code>T | list[T]</code> <p>The result(s) from the operation(s).</p> RAISES DESCRIPTION <code>Exception</code> <p>Any exception raised by the underlying operation(s).</p> <p>Examples:</p> <p>Single ref: <pre><code>data = aviato.results(sandbox.read_file(\"/path\"))\n</code></pre></p> <p>Multiple refs: <pre><code>all_results = aviato.results([sb.read_file(f) for f in files])\n</code></pre></p>"},{"location":"api/#aviato.wait","title":"wait","text":"<pre><code>wait(\n    waitables: Sequence[Waitable],\n    num_returns: int | None = None,\n    timeout: float | None = None,\n) -&gt; tuple[list[Waitable], list[Waitable]]\n</code></pre> <p>Wait for waitables to complete, return (done, pending).</p> <p>Each waitable type has natural \"wait for\" behavior: - Sandbox: waits until RUNNING status - OperationRef: waits until operation completes - Process: waits until process completes</p> PARAMETER DESCRIPTION <code>waitables</code> <p>Sequence of Sandbox, OperationRef, or Process objects.</p> <p> TYPE: <code>Sequence[Waitable]</code> </p> <code>num_returns</code> <p>If specified, return after this many complete. If None, wait for all to complete.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Maximum seconds to wait. If None, wait forever.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[list[Waitable], list[Waitable]]</code> <p>Tuple of (done, pending) lists containing the original waitable objects.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If num_returns is less than 1.</p> <p>Examples:</p> <p>Wait for all sandboxes to be running: <pre><code>sandboxes = [Sandbox.run(...) for _ in range(5)]\ndone, pending = aviato.wait(sandboxes)\n</code></pre></p> <p>Wait for first 2 operations to complete: <pre><code>refs = [sb.read_file(f) for f in files]\ndone, pending = aviato.wait(refs, num_returns=2)\n</code></pre></p> <p>Wait with timeout: <pre><code>done, pending = aviato.wait(procs, timeout=30.0)\n</code></pre></p>"},{"location":"tutorial/01-first-sandbox/","title":"1. Your First Sandbox","text":"<pre><code>pip install aviato\nexport AVIATO_API_KEY=\"your-api-key\"\n</code></pre> <pre><code>from aviato import Sandbox\n\nwith Sandbox.run() as sandbox:\n    result = sandbox.exec([\"echo\", \"Hello!\"]).result()\n    print(result.stdout)\n</code></pre> <p>What's happening: - <code>Sandbox.run()</code> creates a sandbox - <code>exec()</code> runs a command, returning immediately - <code>.result()</code> blocks until complete</p> <p>This non-blocking pattern lets you run operations in parallel.</p>"},{"location":"tutorial/02-configuration/","title":"2. Configuring Sandboxes","text":"<p>Use <code>SandboxDefaults</code> to configure sandboxes:</p> <pre><code>from aviato import Sandbox, SandboxDefaults\n\ndefaults = SandboxDefaults(\n    container_image=\"python:3.11\",\n    max_lifetime_seconds=300,\n    tags=(\"my-app\",),\n)\n\nwith Sandbox.run(defaults=defaults) as sandbox:\n    sandbox.exec([\"python\", \"--version\"]).result()\n</code></pre>"},{"location":"tutorial/03-running-commands/","title":"3. Running Commands","text":"<pre><code># Basic command\nsandbox.exec([\"echo\", \"Hello\"]).result()\n\n# Raise on failure\nsandbox.exec([\"ls\", \"/nonexistent\"], check=True).result()\n\n# With timeout\nsandbox.exec([\"sleep\", \"60\"], timeout_seconds=5).result()\n\n# In a specific directory\nsandbox.exec([\"ls\"], cwd=\"/app\").result()\n</code></pre>"},{"location":"tutorial/03-running-commands/#parallel-execution","title":"Parallel Execution","text":"<p><code>exec()</code> returns immediately - use this for parallelism:</p> <pre><code>p1 = sandbox.exec([\"sleep\", \"1\"])\np2 = sandbox.exec([\"sleep\", \"1\"])\np3 = sandbox.exec([\"sleep\", \"1\"])\n\n# ~1 second total, not 3\np1.result(); p2.result(); p3.result()\n</code></pre> <p>See <code>Sandbox.exec()</code> for all options.</p>"},{"location":"tutorial/04-streaming/","title":"4. Streaming Output","text":"<p>Get output as it happens instead of waiting for completion:</p> <pre><code>process = sandbox.exec([\"bash\", \"-c\", \"for i in 1 2 3; do echo $i; sleep 1; done\"])\n\nfor line in process.stdout:\n    print(line, end=\"\")\n\nresult = process.result()\n</code></pre> <p>Important: Iterate <code>stdout</code> before calling <code>.result()</code>.</p> <p>If output is buffered, use <code>print(..., flush=True)</code> in your script or run with <code>python -u</code>.</p>"},{"location":"tutorial/05-files/","title":"5. Reading &amp; Writing Files","text":"<pre><code># Write (content must be bytes)\nsandbox.write_file(\"/tmp/hello.txt\", b\"Hello!\").result()\n\n# Read (returns bytes)\ncontent = sandbox.read_file(\"/tmp/hello.txt\").result()\nprint(content.decode())\n</code></pre> <p>File operations also return immediately, so you can parallelize:</p> <pre><code>refs = [sandbox.write_file(f\"/tmp/{i}.txt\", b\"data\") for i in range(5)]\nfor ref in refs:\n    ref.result()\n</code></pre>"},{"location":"tutorial/06-multiple-sandboxes/","title":"6. Managing Multiple Sandboxes","text":"<p>Sessions manage multiple sandboxes with shared defaults and automatic cleanup:</p> <pre><code>from aviato import Sandbox, SandboxDefaults\n\ndefaults = SandboxDefaults(container_image=\"python:3.11\", tags=(\"my-app\",))\n\nwith Sandbox.session(defaults) as session:\n    sb1 = session.sandbox()\n    sb2 = session.sandbox()\n\n    p1 = sb1.exec([\"echo\", \"one\"])\n    p2 = sb2.exec([\"echo\", \"two\"])\n\n    print(p1.result().stdout, p2.result().stdout)\n# All sandboxes cleaned up\n</code></pre>"},{"location":"tutorial/07-remote-functions/","title":"7. Remote Function Execution","text":"<p>Run Python functions in sandboxes without writing command strings:</p> <pre><code>from aviato import Sandbox, SandboxDefaults\n\nwith Sandbox.session(SandboxDefaults()) as session:\n    @session.function()\n    def add(x: int, y: int) -&gt; int:\n        return x + y\n\n    result = add.remote(2, 3).result()  # 5\n</code></pre> <p>Parallel execution with <code>.map()</code>:</p> <pre><code>    @session.function()\n    def square(x: int) -&gt; int:\n        return x * x\n\n    refs = square.map([(1,), (2,), (3,)])\n    results = [r.result() for r in refs]  # [1, 4, 9]\n</code></pre>"},{"location":"tutorial/08-cleanup/","title":"8. Cleanup &amp; Orphan Recovery","text":"<p>Context managers handle cleanup automatically:</p> <pre><code>with Sandbox.run() as sandbox:\n    sandbox.exec([\"echo\", \"hello\"]).result()\n# Stopped automatically\n</code></pre> <p>The SDK also cleans up on script exit and Ctrl+C.</p> <p>To find orphaned sandboxes (e.g., from a crash), use tags:</p> <pre><code>sandboxes = Sandbox.list(tags=[\"my-app\"]).result()\nfor sb in sandboxes:\n    sb.stop(missing_ok=True).result()\n</code></pre> <p>Tutorial complete! See the Advanced section or API Reference for more.</p>"}]}